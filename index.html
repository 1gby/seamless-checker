<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rud3boy™ Seamless Pattern Tester</title>
<style>
  body { margin:0; padding:0; font-family:system-ui, sans-serif; background:#111; color:#eee; }
  #container { display:flex; flex-direction:column; height:100vh; box-sizing:border-box; }
  #controls { padding:0.5rem; background:#222; text-align:center; display:flex; gap:0.5rem; justify-content:center; flex-wrap:wrap; align-items:center; font-size:0.85rem; flex-shrink:0; }
  #controls-bottom { padding:0.5rem; background:#222; text-align:center; display:flex; gap:0.5rem; justify-content:center; flex-wrap:wrap; align-items:center; font-size:0.85rem; flex-shrink:0; overflow-y:auto; max-height:40vh; }
  #logo { height:32px; width:auto; object-fit:contain; }
  .title-group { display:flex; align-items:center; gap:0.4rem; }
  #canvas { flex:1; image-rendering:pixelated; touch-action:none; margin:0 auto; display:block; width:100%; min-height:200px; }
  button, input, select { padding:0.4rem 0.7rem; font-size:0.85rem; }
  .bg-btn { width:32px; height:32px; border-radius:50%; border:2px solid #444; cursor:pointer; transition: transform 0.2s; flex-shrink:0; }
  .bg-btn:hover { transform: scale(1.1); }
  .bg-btn.active { border-color: #4da6ff; border-width: 3px; }
  label { display:flex; align-items:center; gap:0.4rem; white-space:nowrap; }
  .slider-group { display:flex; flex-direction:column; align-items:center; min-width:120px; }
  #footer { padding:0.5rem; background:#1a1a1a; text-align:center; font-size:0.75rem; position:fixed; bottom:0; width:100%; border-top:1px solid #333; max-height:120px; overflow-y:auto; z-index:10; box-sizing:border-box; }
  #footer p { margin:0.3rem 0; }
  #footer a { color:#4da6ff; text-decoration:none; margin:0 0.3rem; font-size:0.75rem; }
  #footer a:hover { text-decoration:underline; }
</style>
</head>
<body>
<div id="container">
  <div id="controls">
    <div class="title-group">
      <img id="logo" src="https://i.imgur.com/tlVfJ54.png" alt="Rud3boy Logo">
      <h2>Rud3boy™ Pattern Checker</h2>
    </div>
  </div>

<canvas id="canvas"></canvas>

  <div id="controls-bottom">

<input type="file" id="fileInput" accept="image/*">

<select id="repeatType">
  <option value="full">Full Drop</option>
  <option value="half-drop">Half Drop</option>
  <option value="brick">Brick</option>
</select>

<button id="toggleGrid">Show Grid</button>

<button class="bg-btn active" style="background:#111111;" data-bg="#111111" title="Dark Gray"></button>
<button class="bg-btn" style="background:#ffffff;" data-bg="#ffffff" title="White"></button>
<button class="bg-btn" style="background:#000000;" data-bg="#000000" title="Black"></button>
<button class="bg-btn" style="background:#808080;" data-bg="#808080" title="Gray"></button>
<button class="bg-btn" style="background:repeating-conic-gradient(#ccc 0% 25%,#999 0% 50%,#ccc 50% 75%,#999 75% 100%); background-size:40px 40px;" data-bg="checker" title="Checker"></button>

<select id="viewMode">
  <option value="tile">Infinite Tile</option>
  <option value="phone">Phone Case Mockup</option>
  <option value="fabric">Fabric Swatch Mockup</option>
</select>

<button id="exportBtn">Export PNG</button>

<div class="slider-group">
  <label>Scale: <input type="range" id="patternScale" min="0.3" max="3" step="0.1" value="1"></label>
  <span id="scaleValue">1×</span>
</div>

<div class="slider-group">
  <label>Offset X: <input type="range" id="offsetX" min="0" max="100" value="0"></label>
  <span id="offsetXValue">0%</span>
</div>

<div class="slider-group">
  <label>Offset Y: <input type="range" id="offsetY" min="0" max="100" value="0"></label>
  <span id="offsetYValue">0%</span>
</div>

<p style="margin:0.3rem 0 0; font-size:0.75rem; width:100%;">Drag & drop square tile | Wheel/Pinch zoom | Drag to pan</p>

  </div>
</div>

<div id="footer">
  <p>Turn your patterns into real products! Upload to these popular Print-on-Demand sites:</p>
  <p>
    <a href="https://www.spoonflower.com/" target="_blank">Spoonflower</a> (fabrics, wallpaper, home decor) •
    <a href="https://www.printful.com/" target="_blank">Printful</a> (mugs, apparel, accessories) •
    <a href="https://printify.com/" target="_blank">Printify</a> (mugs, dishes, homeware) •
    <a href="https://society6.com/" target="_blank">Society6</a> (art prints, mugs, decor) •
    <a href="https://www.redbubble.com/" target="_blank">Redbubble</a> (wide range) •
    <a href="https://www.zazzle.com/" target="_blank">Zazzle</a> (custom mugs, dishes, fabrics)
  </p>
</div>

<script>
function roundRect(ctx, x, y, width, height, radius) {
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.arcTo(x + width, y, x + width, y + radius, radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
  ctx.lineTo(x + radius, y + height);
  ctx.arcTo(x, y + height, x, y + height - radius, radius);
  ctx.lineTo(x, y + radius);
  ctx.arcTo(x, y, x + radius, y, radius);
  ctx.closePath();
}

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const fileInput = document.getElementById('fileInput');
const toggleGridBtn = document.getElementById('toggleGrid');
const repeatSelect = document.getElementById('repeatType');
const viewModeSelect = document.getElementById('viewMode');
const exportBtn = document.getElementById('exportBtn');
const scaleSlider = document.getElementById('patternScale');
const offsetXSlider = document.getElementById('offsetX');
const offsetYSlider = document.getElementById('offsetY');
const scaleValue = document.getElementById('scaleValue');
const offsetXValue = document.getElementById('offsetXValue');
const offsetYValue = document.getElementById('offsetYValue');

let tileImg = null;
let showGrid = false;
let repeatType = 'full';
let bgColor = '#111111';
let viewMode = 'tile';
let patternScale = 1;
let offsetPercentX = 0;
let offsetPercentY = 0;

let offsetX = 0, offsetY = 0, scale = 1;
let isDragging = false, startX, startY;

function resize() {
  const controlsTop = document.getElementById('controls').offsetHeight;
  const controlsBottom = document.getElementById('controls-bottom').offsetHeight;
  const footer = document.getElementById('footer').offsetHeight;
  const availableHeight = window.innerHeight - controlsTop - controlsBottom - footer;
  const availableWidth = window.innerWidth;
  
  const size = Math.min(availableWidth, availableHeight);
  canvas.width = size;
  canvas.height = size;
  
  updateBackground();
  draw();
}
window.addEventListener('resize', resize);
resize();

function updateBackground() {
  if (tileImg) {
    canvas.style.background = bgColor === 'checker' 
      ? 'repeating-conic-gradient(#ccc 0% 25%, #999 0% 50%, #ccc 50% 75%, #999 75% 100%)' 
      : bgColor;
    canvas.style.backgroundSize = '40px 40px';
  } else {
    canvas.style.background = 'repeating-conic-gradient(#2a2a2a 0% 25%, #1a1a1a 0% 50%, #2a2a2a 50% 75%, #1a1a1a 75% 100%)';
    canvas.style.backgroundSize = '40px 40px';
  }
}

function drawPattern(startX, startY, width, height, tileSize) {
  const tilesX = Math.ceil(width / tileSize) + 4;
  const tilesY = Math.ceil(height / tileSize) + 4;
  
  for (let x = -2; x < tilesX; x++) {
    for (let y = -2; y < tilesY; y++) {
      let drawX = startX + x * tileSize + offsetPercentX * tileSize;
      let drawY = startY + y * tileSize + offsetPercentY * tileSize;

      if (repeatType === 'half-drop') {
        drawY += (Math.abs(x) % 2 === 1) ? tileSize / 2 : 0;
      } else if (repeatType === 'brick') {
        drawX += (Math.abs(y) % 2 === 1) ? tileSize / 2 : 0;
      }

      ctx.drawImage(tileImg, drawX, drawY, tileSize, tileSize);
    }
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!tileImg) {
    ctx.fillStyle = '#888';
    ctx.font = '1.5rem system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Drop your square pattern tile here to start!', canvas.width/2, canvas.height/2);
    return;
  }

  const baseTileSize = tileImg.width;
  const effectiveTileSize = baseTileSize * patternScale;

  ctx.save();

  if (viewMode === 'tile') {
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);

    const tilesX = Math.ceil(canvas.width / effectiveTileSize / scale) + 6;
    const tilesY = Math.ceil(canvas.height / effectiveTileSize / scale) + 6;
    const startTileX = Math.floor(-offsetX / (effectiveTileSize * scale)) - 3;
    const startTileY = Math.floor(-offsetY / (effectiveTileSize * scale)) - 3;

    for (let x = startTileX; x < startTileX + tilesX; x++) {
      for (let y = startTileY; y < startTileY + tilesY; y++) {
        let drawX = x * effectiveTileSize + offsetPercentX * effectiveTileSize;
        let drawY = y * effectiveTileSize + offsetPercentY * effectiveTileSize;

        if (repeatType === 'half-drop') drawY += (Math.abs(x) % 2 === 1) ? effectiveTileSize / 2 : 0;
        else if (repeatType === 'brick') drawX += (Math.abs(y) % 2 === 1) ? effectiveTileSize / 2 : 0;

        ctx.drawImage(tileImg, drawX, drawY, effectiveTileSize, effectiveTileSize);
      }
    }

    if (showGrid) {
      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.lineWidth = 1 / scale;

      for (let x = startTileX; x < startTileX + tilesX + 1; x++) {
        let lineX = x * effectiveTileSize + offsetPercentX * effectiveTileSize;
        ctx.beginPath();
        ctx.moveTo(lineX, startTileY * effectiveTileSize - effectiveTileSize);
        ctx.lineTo(lineX, (startTileY + tilesY + 1) * effectiveTileSize);
        ctx.stroke();
      }
      for (let y = startTileY; y < startTileY + tilesY + 1; y++) {
        let lineY = y * effectiveTileSize + offsetPercentY * effectiveTileSize;
        ctx.beginPath();
        ctx.moveTo(startTileX * effectiveTileSize - effectiveTileSize, lineY);
        ctx.lineTo((startTileX + tilesX + 1) * effectiveTileSize, lineY);
        ctx.stroke();
      }
    }
  } else {
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const mockupSize = Math.min(canvas.width, canvas.height) * 0.6;

    ctx.translate(centerX, centerY);

    if (viewMode === 'phone') {
      const phoneWidth = mockupSize * 0.5;
      const phoneHeight = phoneWidth * 2;
      
      roundRect(ctx, -phoneWidth/2, -phoneHeight/2, phoneWidth, phoneHeight, 30);
      ctx.fillStyle = '#1a1a1a';
      ctx.fill();
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.clip();

      drawPattern(-phoneWidth/2, -phoneHeight/2, phoneWidth, phoneHeight, effectiveTileSize);
      
    } else if (viewMode === 'fabric') {
      const fabricWidth = mockupSize * 0.8;
      const fabricHeight = fabricWidth * 0.75;
      
      roundRect(ctx, -fabricWidth/2, -fabricHeight/2, fabricWidth, fabricHeight, 15);
      ctx.fillStyle = '#2a2a2a';
      ctx.fill();
      ctx.strokeStyle = '#444';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.clip();

      drawPattern(-fabricWidth/2, -fabricHeight/2, fabricWidth, fabricHeight, effectiveTileSize);
    }
  }

  ctx.restore();
}

function loadImage(file) {
  if (!file) return;
  const reader = new FileReader();
  reader.onload = e => {
    tileImg = new Image();
    tileImg.onload = () => {
      updateBackground();
      draw();
    };
    tileImg.src = e.target.result;
  };
  reader.readAsDataURL(file);
}

fileInput.addEventListener('change', e => loadImage(e.target.files[0]));
canvas.addEventListener('dragover', e => e.preventDefault());
canvas.addEventListener('drop', e => {
  e.preventDefault();
  loadImage(e.dataTransfer.files[0]);
});

canvas.addEventListener('pointerdown', e => {
  if (viewMode !== 'tile') return;
  isDragging = true;
  startX = e.clientX - offsetX;
  startY = e.clientY - offsetY;
  canvas.setPointerCapture(e.pointerId);
});
canvas.addEventListener('pointermove', e => {
  if (!isDragging || viewMode !== 'tile') return;
  offsetX = e.clientX - startX;
  offsetY = e.clientY - startY;
  draw();
});
canvas.addEventListener('pointerup', () => isDragging = false);
canvas.addEventListener('pointerleave', () => isDragging = false);

canvas.addEventListener('wheel', e => {
  if (viewMode !== 'tile') return;
  e.preventDefault();
  const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
  const mouseX = e.clientX, mouseY = e.clientY;
  const newScale = scale * zoomFactor;
  const scaleChange = newScale - scale;
  offsetX -= (mouseX - offsetX) * (scaleChange / scale);
  offsetY -= (mouseY - offsetY) * (scaleChange / scale);
  scale = newScale;
  draw();
}, { passive: false });

let lastTouchDistance = 0;
canvas.addEventListener('touchstart', e => {
  if (e.touches.length === 2 && viewMode === 'tile') {
    e.preventDefault();
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    lastTouchDistance = Math.hypot(
      touch2.clientX - touch1.clientX,
      touch2.clientY - touch1.clientY
    );
  }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  if (e.touches.length === 2 && viewMode === 'tile') {
    e.preventDefault();
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    const currentDistance = Math.hypot(
      touch2.clientX - touch1.clientX,
      touch2.clientY - touch1.clientY
    );
    
    if (lastTouchDistance > 0) {
      const zoomFactor = currentDistance / lastTouchDistance;
      const centerX = (touch1.clientX + touch2.clientX) / 2;
      const centerY = (touch1.clientY + touch2.clientY) / 2;
      
      const newScale = scale * zoomFactor;
      const scaleChange = newScale - scale;
      offsetX -= (centerX - offsetX) * (scaleChange / scale);
      offsetY -= (centerY - offsetY) * (scaleChange / scale);
      scale = newScale;
      draw();
    }
    
    lastTouchDistance = currentDistance;
  }
}, { passive: false });

canvas.addEventListener('touchend', () => {
  lastTouchDistance = 0;
});

repeatSelect.addEventListener('change', e => { repeatType = e.target.value; draw(); });
viewModeSelect.addEventListener('change', e => { viewMode = e.target.value; draw(); });
toggleGridBtn.addEventListener('click', () => {
  showGrid = !showGrid;
  toggleGridBtn.textContent = showGrid ? 'Hide Grid' : 'Show Grid';
  draw();
});

document.querySelectorAll('.bg-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.bg-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    bgColor = btn.dataset.bg;
    updateBackground();
    draw();
  });
});

scaleSlider.addEventListener('input', e => {
  patternScale = parseFloat(e.target.value);
  scaleValue.textContent = patternScale.toFixed(1) + '×';
  draw();
});
offsetXSlider.addEventListener('input', e => {
  offsetPercentX = e.target.value / 100;
  offsetXValue.textContent = e.target.value + '%';
  draw();
});
offsetYSlider.addEventListener('input', e => {
  offsetPercentY = e.target.value / 100;
  offsetYValue.textContent = e.target.value + '%';
  draw();
});
exportBtn.addEventListener('click', () => {
  const link = document.createElement('a');
  link.download = 'rud3boy-pattern.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
});

draw();

const demoImg = new Image();
demoImg.crossOrigin = "anonymous";
demoImg.onload = () => {
  tileImg = demoImg;
  updateBackground();
  draw();
};
demoImg.onerror = () => {
  console.log('Demo image failed to load');
};
demoImg.src = "https://i.imgur.com/hKiKJUG.png";
</script>

</body>
</html>