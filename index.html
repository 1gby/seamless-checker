<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Seamless Pattern Checker by Rudeboy™</title>
<style>
  body { margin:0; padding:0; font-family:system-ui, sans-serif; background:#111; color:#eee; }
  #container { display:flex; flex-direction:column; }
  #controls { padding:0.8rem; background:#222; text-align:center; display:flex; gap:0.6rem; justify-content:center; flex-wrap:wrap; align-items:center; font-size:0.9rem; }
  #controls-bottom { padding:1rem 0.8rem 1.5rem; background:#222; text-align:center; display:flex; gap:0.8rem; justify-content:center; flex-wrap:wrap; align-items:center; font-size:0.9rem; }
  #logo { height:36px; width:auto; object-fit:contain; cursor:pointer; }
  .title-group { display:flex; align-items:center; gap:0.5rem; }
  #canvas { width:100%; max-width:100vw; aspect-ratio:1; image-rendering: auto; touch-action:none; display:block; margin:0; }
  button, input, select { padding:0.6rem 0.9rem; font-size:0.9rem; border-radius:8px; }
  label { display:flex; align-items:center; gap:0.4rem; white-space:nowrap; }
  .slider-group { display:flex; flex-direction:column; align-items:center; min-width:140px; gap:0.3rem; }
  .slider-group input[type="range"] { width:120px; }
  #footer { padding:1rem; background:#1a1a1a; text-align:center; font-size:0.85rem; border-top:1px solid #333; }
  #footer p { margin:0.4rem 0; line-height:1.5; }
  #footer a { color:#4da6ff; text-decoration:none; margin:0 0.5rem; font-size:0.85rem; display:inline-block; }
  #footer a:hover { text-decoration:underline; }
</style>
</head>
<body>
<div id="container">
  <div id="controls">
    <div class="title-group">
      <img id="logo" src="https://i.imgur.com/tlVfJ54.png" alt="Rud3boy Logo">
      <h2>Rud3boy™ Pattern Checker</h2>
    </div>
  </div>

<canvas id="canvas"></canvas>

  <div id="controls-bottom">
    <input type="file" id="fileInput" accept="image/*">

<select id="repeatType">
  <option value="full">Full Drop</option>
  <option value="half-drop">Half Drop</option>
  <option value="brick">Brick</option>
</select>

<button id="toggleGrid">Show Grid</button>

<select id="bgColor">
  <option value="checker">Transparent</option>
  <option value="#000000">Black</option>
  <option value="#ffffff">White</option>
</select>

<select id="viewMode">
  <option value="tile">Infinite Tile</option>
  <option value="phone">Phone Case Mockup</option>
  <option value="fabric">Fabric Swatch Mockup</option>
  <option value="bottle">Water Bottle Mockup</option>
</select>

<button id="exportBtn">Export PNG</button>

<div class="slider-group">
  <label>Scale: <input type="range" id="patternScale" min="0.3" max="3" step="0.1" value="1"></label>
  <span id="scaleValue">1×</span>
</div>

<div class="slider-group">
  <label>Offset X: <input type="range" id="offsetX" min="0" max="100" value="0"></label>
  <span id="offsetXValue">0%</span>
</div>

<div class="slider-group">
  <label>Offset Y: <input type="range" id="offsetY" min="0" max="100" value="0"></label>
  <span id="offsetYValue">0%</span>
</div>

<p style="margin:0.5rem 0 0; font-size:0.85rem; width:100%;">Drag & drop square tile | Wheel/Pinch zoom | Drag to pan</p>

  </div>
</div>

<div id="footer">
  <p>Turn your patterns into real products! Upload to these popular Print-on-Demand sites:</p>
  <p>
    <a href="https://www.spoonflower.com/" target="_blank">Spoonflower</a> (fabrics, wallpaper, home decor) •
    <a href="https://www.printful.com/" target="_blank">Printful</a> (mugs, apparel, accessories) •
    <a href="https://printify.com/" target="_blank">Printify</a> (mugs, dishes, homeware) •
    <a href="https://society6.com/" target="_blank">Society6</a> (art prints, mugs, decor) •
    <a href="https://www.redbubble.com/" target="_blank">Redbubble</a> (wide range) •
    <a href="https://www.zazzle.com/" target="_blank">Zazzle</a> (custom mugs, dishes, fabrics)
  </p>
  <p style="color:#ff0000; font-weight:bold; margin-top:1rem;">Created by Rudeboy™</p>
</div>

<script>
function roundRect(ctx, x, y, width, height, radius) {
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.arcTo(x + width, y, x + width, y + radius, radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
  ctx.lineTo(x + radius, y + height);
  ctx.arcTo(x, y + height, x, y + height - radius, radius);
  ctx.lineTo(x, y + radius);
  ctx.arcTo(x, y, x + radius, y, radius);
  ctx.closePath();
}

const canvas = document.getElementById('canvas');
const ctx = canvas.addEventListener('wheel',e=>{if(viewMode!=='tile'||!tileImg)return;e.preventDefault();const zf=e.deltaY<0?1.1:0.9,r=canvas.getBoundingClientRect(),mx=e.clientX-r.left,my=e.clientY-r.top;let ns=zoomScale*zf;ns=Math.max(MIN_ZOOM,Math.min(MAX_ZOOM,ns));const sc=ns-zoomScale;panOffsetX-=(mx-panOffsetX)*(sc/zoomScale);panOffsetY-=(my-panOffsetY)*(sc/zoomScale);zoomScale=ns;draw()},{passive:false});
let ltd=0;
canvas.addEventListener('touchstart',e=>{if(e.touches.length===2&&viewMode==='tile'&&tileImg){e.preventDefault();const t1=e.touches[0],t2=e.touches[1];ltd=Math.hypot(t2.clientX-t1.clientX,t2.clientY-t1.clientY)}},{passive:false});
canvas.addEventListener('touchmove',e=>{if(e.touches.length===2&&viewMode==='tile'&&tileImg){e.preventDefault();const t1=e.touches[0],t2=e.touches[1],cd=Math.hypot(t2.clientX-t1.clientX,t2.clientY-t1.clientY);if(ltd>0){const zf=cd/ltd,r=canvas.getBoundingClientRect(),cx=((t1.clientX+t2.clientX)/2)-r.left,cy=((t1.clientY+t2.clientY)/2)-r.top;let ns=zoomScale*zf;ns=Math.max(MIN_ZOOM,Math.min(MAX_ZOOM,ns));const sc=ns-zoomScale;panOffsetX-=(cx-panOffsetX)*(sc/zoomScale);panOffsetY-=(cy-panOffsetY)*(sc/zoomScale);zoomScale=ns;draw()}ltd=cd}},{passive:false});
canvas.addEventListener('touchend',()=>ltd=0);
repeatSelect.addEventListener('change',e=>{repeatType=e.target.value;draw()});
viewModeSelect.addEventListener('change',e=>{viewMode=e.target.value;draw()});
bgColorSelect.addEventListener('change',e=>{bgColor=e.target.value;updateBackground();draw()});
toggleGridBtn.addEventListener('click',()=>{showGrid=!showGrid;toggleGridBtn.textContent=showGrid?'Hide Grid':'Show Grid';draw()});
scaleSlider.addEventListener('input',e=>{patternScale=parseFloat(e.target.value);scaleValue.textContent=patternScale.toFixed(1)+'×';draw()});
offsetXSlider.addEventListener('input',e=>{offsetPercentX=e.target.value/100;offsetXValue.textContent=e.target.value+'%';draw()});
offsetYSlider.addEventListener('input',e=>{offsetPercentY=e.target.value/100;offsetYValue.textContent=e.target.value+'%';draw()});
exportBtn.addEventListener('click',()=>{if(!tileImg){alert('Please load a pattern first!');return}try{const l=document.createElement('a');l.download='rud3boy-pattern.png';l.href=canvas.toDataURL('image/png');l.click()}catch(e){console.error('Export failed:',e);alert('Export failed. Please try again or take a screenshot.')}});
draw();
</script>

</body>
</html>getContext('2d');
const fileInput = document.getElementById('fileInput');
const toggleGridBtn = document.getElementById('toggleGrid');
const repeatSelect = document.getElementById('repeatType');
const viewModeSelect = document.getElementById('viewMode');
const bgColorSelect = document.getElementById('bgColor');
const exportBtn = document.getElementById('exportBtn');
const scaleSlider = document.getElementById('patternScale');
const offsetXSlider = document.getElementById('offsetX');
const offsetYSlider = document.getElementById('offsetY');
const scaleValue = document.getElementById('scaleValue');
const offsetXValue = document.getElementById('offsetXValue');
const offsetYValue = document.getElementById('offsetYValue');

let tileImg = null;
let showGrid = false;
let repeatType = ‘full’;
let bgColor = ‘checker’;
let viewMode = ‘tile’;
let patternScale = 1;
let offsetPercentX = 0;
let offsetPercentY = 0;

let offsetX = 0, offsetY = 0, scale = 1;
let isDragging = false, startX, startY;

const MIN_ZOOM = 0.1;
const MAX_ZOOM = 5;

function resize() {
const availableWidth = window.innerWidth;
canvas.width = availableWidth;
canvas.height = availableWidth;

updateBackground();
draw();
}
window.addEventListener(‘resize’, resize);
resize();

document.getElementById(‘logo’).addEventListener(‘click’, () => {
location.reload();
});

function updateBackground() {
if (tileImg) {
canvas.style.background = bgColor === ‘checker’
? ‘repeating-conic-gradient(#ccc 0% 25%, #999 0% 50%, #ccc 50% 75%, #999 75% 100%)’
: bgColor;
canvas.style.backgroundSize = ‘40px 40px’;
} else {
canvas.style.background = ‘repeating-conic-gradient(#2a2a2a 0% 25%, #1a1a1a 0% 50%, #2a2a2a 50% 75%, #1a1a1a 75% 100%)’;
canvas.style.backgroundSize = ‘40px 40px’;
}
}

function drawPattern(startX, startY, width, height, tileSize) {
const tilesX = Math.ceil(width / tileSize) + 4;
const tilesY = Math.ceil(height / tileSize) + 4;

ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = ‘high’;

for (let x = -2; x < tilesX; x++) {
for (let y = -2; y < tilesY; y++) {
let drawX = startX + x * tileSize + offsetPercentX * tileSize;
let drawY = startY + y * tileSize + offsetPercentY * tileSize;

```
  if (repeatType === 'half-drop') {
    drawY += (Math.abs(x) % 2 === 1) ? tileSize / 2 : 0;
  } else if (repeatType === 'brick') {
    drawX += (Math.abs(y) % 2 === 1) ? tileSize / 2 : 0;
  }

  ctx.drawImage(tileImg, drawX, drawY, tileSize, tileSize);
}
```

}
}

function draw() {
ctx.clearRect(0, 0, canvas.width, canvas.height);
if (!tileImg) {
ctx.fillStyle = ‘#888’;
ctx.font = ‘1.5rem system-ui’;
ctx.textAlign = ‘center’;
ctx.fillText(‘Drop your square pattern tile here to start!’, canvas.width/2, canvas.height/2);
return;
}

const baseTileSize = tileImg.width;
const effectiveTileSize = baseTileSize * patternScale;

ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = ‘high’;

ctx.save();

if (viewMode === ‘tile’) {
ctx.translate(offsetX, offsetY);
ctx.scale(scale, scale);

```
const tilesX = Math.ceil(canvas.width / effectiveTileSize / scale) + 6;
const tilesY = Math.ceil(canvas.height / effectiveTileSize / scale) + 6;
const startTileX = Math.floor(-offsetX / (effectiveTileSize * scale)) - 3;
const startTileY = Math.floor(-offsetY / (effectiveTileSize * scale)) - 3;

for (let x = startTileX; x < startTileX + tilesX; x++) {
  for (let y = startTileY; y < startTileY + tilesY; y++) {
    let drawX = x * effectiveTileSize + offsetPercentX * effectiveTileSize;
    let drawY = y * effectiveTileSize + offsetPercentY * effectiveTileSize;

    if (repeatType === 'half-drop') drawY += (Math.abs(x) % 2 === 1) ? effectiveTileSize / 2 : 0;
    else if (repeatType === 'brick') drawX += (Math.abs(y) % 2 === 1) ? effectiveTileSize / 2 : 0;

    ctx.drawImage(tileImg, drawX, drawY, effectiveTileSize, effectiveTileSize);
  }
}

if (showGrid) {
  ctx.strokeStyle = 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 1 / scale;

  for (let x = startTileX; x < startTileX + tilesX + 1; x++) {
    let lineX = x * effectiveTileSize + offsetPercentX * effectiveTileSize;
    ctx.beginPath();
    ctx.moveTo(lineX, startTileY * effectiveTileSize - effectiveTileSize);
    ctx.lineTo(lineX, (startTileY + tilesY + 1) * effectiveTileSize);
    ctx.stroke();
  }
  for (let y = startTileY; y < startTileY + tilesY + 1; y++) {
    let lineY = y * effectiveTileSize + offsetPercentY * effectiveTileSize;
    ctx.beginPath();
    ctx.moveTo(startTileX * effectiveTileSize - effectiveTileSize, lineY);
    ctx.lineTo((startTileX + tilesX + 1) * effectiveTileSize, lineY);
    ctx.stroke();
  }
}
```

} else {
const centerX = canvas.width / 2;
const centerY = canvas.height / 2;
const mockupSize = Math.min(canvas.width, canvas.height) * 0.6;

```
ctx.translate(centerX, centerY);

if (viewMode === 'phone') {
  const phoneWidth = mockupSize * 0.55;
  const phoneHeight = phoneWidth * 2.1;
  const cameraSize = phoneWidth * 0.15;
  const cameraOffset = phoneWidth * 0.15;
  
  ctx.save();
  roundRect(ctx, -phoneWidth/2, -phoneHeight/2, phoneWidth, phoneHeight, 35);
  ctx.clip();
  drawPattern(-phoneWidth/2, -phoneHeight/2, phoneWidth, phoneHeight, effectiveTileSize);
  ctx.restore();
  
  roundRect(ctx, -phoneWidth/2, -phoneHeight/2, phoneWidth, phoneHeight, 35);
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 4;
  ctx.stroke();
  
  ctx.beginPath();
  ctx.arc(-phoneWidth/2 + cameraOffset + cameraSize/2, -phoneHeight/2 + cameraOffset + cameraSize/2, cameraSize/2, 0, Math.PI * 2);
  ctx.fillStyle = '#0a0a0a';
  ctx.fill();
  ctx.strokeStyle = '#222';
  ctx.lineWidth = 2;
  ctx.stroke();
  
} else if (viewMode === 'fabric') {
  const fabricWidth = mockupSize * 0.95;
  const fabricHeight = fabricWidth * 0.8;
  
  ctx.save();
  roundRect(ctx, -fabricWidth/2, -fabricHeight/2, fabricWidth, fabricHeight, 15);
  ctx.fillStyle = '#2a2a2a';
  ctx.fill();
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.clip();

  drawPattern(-fabricWidth/2, -fabricHeight/2, fabricWidth, fabricHeight, effectiveTileSize);
  ctx.restore();
} else if (viewMode === 'bottle') {
  const bottleWidth = mockupSize * 0.45;
  const bottleHeight = bottleWidth * 2.3;
  const capHeight = bottleHeight * 0.12;
  const neckHeight = bottleHeight * 0.08;
  const bodyTop = -bottleHeight/2 + capHeight + neckHeight;
  const bodyHeight = bottleHeight - capHeight - neckHeight;
  
  ctx.save();
  roundRect(ctx, -bottleWidth/2, bodyTop, bottleWidth, bodyHeight, 25);
  ctx.clip();
  drawPattern(-bottleWidth/2, bodyTop, bottleWidth, bodyHeight, effectiveTileSize);
  ctx.restore();
  
  roundRect(ctx, -bottleWidth/2, bodyTop, bottleWidth, bodyHeight, 25);
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 3;
  ctx.stroke();
  
  ctx.save();
  roundRect(ctx, -bottleWidth/2, bodyTop, bottleWidth, bodyHeight, 25);
  ctx.clip();
  const gradient = ctx.createLinearGradient(-bottleWidth/2, 0, bottleWidth/2, 0);
  gradient.addColorStop(0, 'rgba(255,255,255,0)');
  gradient.addColorStop(0.3, 'rgba(255,255,255,0.15)');
  gradient.addColorStop(0.5, 'rgba(255,255,255,0.25)');
  gradient.addColorStop(0.7, 'rgba(255,255,255,0.15)');
  gradient.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = gradient;
  ctx.fillRect(-bottleWidth/2, bodyTop, bottleWidth, bodyHeight);
  ctx.restore();
  
  const neckWidth = bottleWidth * 0.6;
  ctx.fillStyle = '#e8e8e8';
  roundRect(ctx, -neckWidth/2, -bottleHeight/2 + capHeight, neckWidth, neckHeight, 8);
  ctx.fill();
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  const capWidth = bottleWidth * 0.65;
  ctx.fillStyle = '#2a2a2a';
  roundRect(ctx, -capWidth/2, -bottleHeight/2, capWidth, capHeight, 6);
  ctx.fill();
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1;
  for (let i = 0; i < 4; i++) {
    const y = -bottleHeight/2 + (capHeight / 5) * (i + 1);
    ctx.beginPath();
    ctx.moveTo(-capWidth/2 + 2, y);
    ctx.lineTo(capWidth/2 - 2, y);
    ctx.stroke();
  }
  
  ctx.beginPath();
  ctx.ellipse(0, -bottleHeight/2 + 3, capWidth * 0.45, capWidth * 0.12, 0, 0, Math.PI * 2);
  ctx.fillStyle = '#1a1a1a';
  ctx.fill();
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  ctx.beginPath();
  ctx.ellipse(0, bodyTop + bodyHeight - 5, bottleWidth * 0.48, bottleWidth * 0.08, 0, 0, Math.PI);
  ctx.fillStyle = '#333';
  ctx.fill();
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  ctx.stroke();
}
```

}

ctx.restore();
}

function loadImage(file) {
if (!file) return;
const reader = new FileReader();
reader.onload = e => {
tileImg = new Image();
tileImg.onload = () => {
updateBackground();
draw();
};
tileImg.src = e.target.result;
};
reader.readAsDataURL(file);
}

fileInput.addEventListener(‘change’, e => loadImage(e.target.files[0]));
canvas.addEventListener(‘dragover’, e => e.preventDefault());
canvas.addEventListener(‘drop’, e => {
e.preventDefault();
loadImage(e.dataTransfer.files[0]);
});

canvas.addEventListener(‘pointerdown’, e => {
if (viewMode !== ‘tile’) return;
isDragging = true;
startX = e.clientX - offsetX;
startY = e.clientY - offsetY;
canvas.setPointerCapture(e.pointerId);
});
canvas.addEventListener(‘pointermove’, e => {
if (!isDragging || viewMode !== ‘tile’) return;
offsetX = e.clientX - startX;
offsetY = e.clientY - startY;
draw();
});
canvas.addEventListener(‘pointerup’, () => isDragging = false);
canvas.addEventListener(‘pointerleave’, () => isDragging = false);

canvas.addEventListener(‘wheel’, e => {
if (viewMode !== ‘tile’) return;
e.preventDefault();
const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
const mouseX = e.clientX, mouseY = e.clientY;
let newScale = scale * zoomFactor;

newScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newScale));

const scaleChange = newScale - scale;
offsetX -= (mouseX - offsetX) * (scaleChange / scale);
offsetY -= (mouseY - offsetY) * (scaleChange / scale);
scale = newScale;
draw();
}, { passive: false });

let lastTouchDistance = 0;
canvas.addEventListener(‘touchstart’, e => {
if (e.touches.length === 2 && viewMode === ‘tile’) {
e.preventDefault();
const touch1 = e.touches[0];
const touch2 = e.touches[1];
lastTouchDistance = Math.hypot(
touch2.clientX - touch1.clientX,
touch2.clientY - touch1.clientY
);
}
}, { passive: false });

canvas.addEventListener(‘touchmove’, e => {
if (e.touches.length === 2 && viewMode === ‘tile’) {
e.preventDefault();
const touch1 = e.touches[0];
const touch2 = e.touches[1];
const currentDistance = Math.hypot(
touch2.clientX - touch1.clientX,
touch2.clientY - touch1.clientY
);

```
if (lastTouchDistance > 0) {
  const zoomFactor = currentDistance / lastTouchDistance;
  const centerX = (touch1.clientX + touch2.clientX) / 2;
  const centerY = (touch1.clientY + touch2.clientY) / 2;
  
  let newScale = scale * zoomFactor;
  
  newScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newScale));
  
  const scaleChange = newScale - scale;
  offsetX -= (centerX - offsetX) * (scaleChange / scale);
  offsetY -= (centerY - offsetY) * (scaleChange / scale);
  scale = newScale;
  draw();
}

lastTouchDistance = currentDistance;
```

}
}, { passive: false });

canvas.addEventListener(‘touchend’, () => {
lastTouchDistance = 0;
});

repeatSelect.addEventListener(‘change’, e => { repeatType = e.target.value; draw(); });
viewModeSelect.addEventListener(‘change’, e => { viewMode = e.target.value; draw(); });
bgColorSelect.addEventListener(‘change’, e => {
bgColor = e.target.value;
updateBackground();
draw();
});
toggleGridBtn.addEventListener(‘click’, () => {
showGrid = !showGrid;
toggleGridBtn.textContent = showGrid ? ‘Hide Grid’ : ‘Show Grid’;
draw();
});

scaleSlider.addEventListener(‘input’, e => {
patternScale = parseFloat(e.target.value);
scaleValue.textContent = patternScale.toFixed(1) + ‘×’;
draw();
});
offsetXSlider.addEventListener(‘input’, e => {
offsetPercentX = e.target.value / 100;
offsetXValue.textContent = e.target.value + ‘%’;
draw();
});
offsetYSlider.addEventListener(‘input’, e => {
offsetPercentY = e.target.value / 100;
offsetYValue.textContent = e.target.value + ‘%’;
draw();
});

exportBtn.addEventListener(‘click’, () => {
if (!tileImg) {
alert(‘Please load a pattern first!’);
return;
}

try {
const link = document.createElement(‘a’);
link.download = ‘rud3boy-pattern.png’;
link.href = canvas.toDataURL(‘image/png’);
link.click();
} catch (error) {
console.error(‘Export failed:’, error);
alert(‘Export failed. Please try again or take a screenshot.’);
}
});

draw();
</script>

</body>
</html>